// ZK-STARK Age Verification Prover Program
// This Cairo program is the equivalent of a Circom circuit
// It runs OFF-CHAIN to generate STARK proofs
//
// Similar to the Circom circuit you provided, this program:
// - Takes PRIVATE inputs (age, salt)
// - Takes PUBLIC inputs (minimum_age, age_commitment)
// - Proves: pedersen(age, salt) == age_commitment AND age >= minimum_age
// - Returns: verification status (1 = valid, 0 = invalid)
//
// The proof generated by this program can be verified on-chain
// without revealing the age value.

use core::pedersen::pedersen;
use core::traits::Into;

/// Public inputs structure
/// These values are visible to everyone verifying the proof
#[derive(Drop, Serde)]
struct PublicInputs {
    minimum_age: u8,           // Required minimum age (e.g., 18)
    age_commitment: felt252,   // Pedersen commitment stored on-chain
    user_id: felt252,          // User identifier
}

/// Private inputs structure
/// These values are NEVER revealed - only known to the prover
#[derive(Drop, Serde)]
struct PrivateInputs {
    age: u8,                   // User's actual age (PRIVATE)
    salt: felt252,             // Random salt used in commitment (PRIVATE)
}

/// Verification result
#[derive(Drop, Serde)]
struct VerificationResult {
    is_valid: felt252,         // 1 if valid, 0 if invalid
    proof_hash: felt252,       // Hash of the verification for audit
}

/// Main proving function
/// This is the STARK circuit logic
fn prove_age_verification(
    public_inputs: PublicInputs,
    private_inputs: PrivateInputs
) -> VerificationResult {
    // STEP 1: Verify the commitment
    // Recompute: pedersen(age, salt)
    let age_felt: felt252 = private_inputs.age.into();
    let computed_commitment = pedersen(age_felt, private_inputs.salt);

    // Check if computed commitment matches the public commitment
    // This proves we know the correct age and salt
    let commitment_valid = computed_commitment == public_inputs.age_commitment;

    // STEP 2: Verify age range
    // Check if age >= minimum_age
    let age_valid = private_inputs.age >= public_inputs.minimum_age;

    // STEP 3: Combine both checks
    // Both must be true for verification to pass
    let is_valid = commitment_valid && age_valid;

    // Convert boolean to felt252 (1 or 0)
    let is_valid_felt = if is_valid {
        1
    } else {
        0
    };

    // STEP 4: Generate proof hash for audit trail
    // This doesn't reveal age, but allows verification tracking
    let proof_hash = pedersen(
        public_inputs.user_id,
        pedersen(public_inputs.age_commitment, public_inputs.minimum_age.into())
    );

    VerificationResult {
        is_valid: is_valid_felt,
        proof_hash
    }
}

/// Main entry point for the Cairo program
/// This will be executed to generate the STARK proof
fn main() -> VerificationResult {
    // PUBLIC INPUTS (visible to verifier)
    let public_inputs = PublicInputs {
        minimum_age: 18,
        age_commitment: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef,
        user_id: 0x9876543210,
    };

    // PRIVATE INPUTS (known only to prover)
    let private_inputs = PrivateInputs {
        age: 25,
        salt: 0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890,
    };

    // Run the proving computation
    prove_age_verification(public_inputs, private_inputs)
}